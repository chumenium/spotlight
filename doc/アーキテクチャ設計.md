# SpotLight アーキテクチャ設計

## プロジェクト構成

```
lib/
├── config/              # 設定ファイル
│   ├── app_config.dart      # アプリ全体の設定
│   ├── firebase_config.dart # Firebase関連の設定
│   └── README.md
│
├── services/            # サービス層（ビジネスロジック）
│   ├── firebase_service.dart # Firebase初期化
│   ├── auth_service.dart     # 認証ユーティリティ
│   └── README.md
│
├── providers/           # 状態管理（Provider）
│   ├── auth_provider.dart        # 認証状態管理
│   └── navigation_provider.dart  # ナビゲーション状態管理
│
├── models/              # データモデル
│   ├── notification.dart
│   ├── post.dart
│   └── search_history.dart
│
├── screens/             # 画面
│   ├── login_screen.dart
│   ├── register_screen.dart
│   ├── home_screen.dart
│   ├── search_screen.dart
│   ├── create_post_screen.dart
│   ├── notifications_screen.dart
│   └── profile_screen.dart
│
├── widgets/             # 共通ウィジェット
│   └── bottom_navigation_bar.dart
│
├── utils/               # ユーティリティ
│   └── spotlight_colors.dart
│
└── main.dart            # エントリーポイント
```

## レイヤー構造

### 1. Presentation Layer（プレゼンテーション層）
**責務**: UI の表示とユーザーインタラクション

**構成要素**:
- `screens/` - 各画面のウィジェット
- `widgets/` - 再利用可能な UI コンポーネント

**依存関係**:
- Provider から状態を取得
- Service を直接呼ぶことは避ける（Provider 経由）

### 2. State Management Layer（状態管理層）
**責務**: アプリケーション状態の管理

**構成要素**:
- `providers/` - Provider を使った状態管理クラス

**特徴**:
- ChangeNotifier を継承
- 状態の変更を通知（notifyListeners）
- Service 層を呼び出してビジネスロジックを実行

### 3. Business Logic Layer（ビジネスロジック層）
**責務**: ビジネスロジックとユーティリティ機能

**構成要素**:
- `services/` - 各種サービスクラス

**特徴**:
- ステートレス（状態を持たない）
- 再利用可能な共通ロジック
- Firebase などの外部サービスとの通信

### 4. Data Layer（データ層）
**責務**: データモデルの定義

**構成要素**:
- `models/` - データクラス

**特徴**:
- イミュータブルなデータクラス
- JSON シリアライゼーション

### 5. Configuration Layer（設定層）
**責務**: アプリケーション設定の一元管理

**構成要素**:
- `config/` - 設定ファイル

**特徴**:
- 定数の管理
- 環境別設定
- 機能フラグ

## データフロー

```
User Action (Screen)
      ↓
Provider (State Management)
      ↓
Service (Business Logic)
      ↓
Firebase / API
      ↓
Service (Response)
      ↓
Provider (Update State)
      ↓
Screen (UI Update)
```

## Firebase 認証の実装パターン

### 初期化フロー

```dart
main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // 1. Firebase初期化（FirebaseService）
  await FirebaseService.instance.initialize();
  
  // 2. アプリ起動
  runApp(SpotLightApp());
}
```

### 認証フロー

```dart
// ユーザーアクション（画面）
onPressed: () async {
  // 2. Providerのメソッドを呼び出し
  final success = await authProvider.login(email, password);
  
  if (success) {
    // 画面遷移
  } else {
    // エラー表示
    print(authProvider.errorMessage);
  }
}

// AuthProvider（状態管理）
Future<bool> login(String email, String password) async {
  try {
    // 3. Firebase Authを呼び出し
    await _firebaseAuth.signInWithEmailAndPassword(...);
    return true;
  } on FirebaseAuthException catch (e) {
    // 4. エラーをAuthServiceで変換
    _errorMessage = AuthService.getAuthErrorMessage(e);
    return false;
  }
}
```

## 設計原則

### SOLID 原則の適用

#### 1. Single Responsibility Principle（単一責任の原則）
- 各クラスは一つの責任のみを持つ
- 例: `FirebaseService` は初期化のみ、`AuthService` は認証ユーティリティのみ

#### 2. Open/Closed Principle（開放閉鎖の原則）
- 拡張に対して開いている、修正に対して閉じている
- 例: 新しい認証方法を追加する際、既存コードを変更しない

#### 3. Liskov Substitution Principle（リスコフの置換原則）
- サブクラスは基底クラスと置き換え可能
- 例: 将来的な抽象化（インターフェース）の準備

#### 4. Interface Segregation Principle（インターフェース分離の原則）
- クライアントは使用しないメソッドに依存すべきでない
- 例: Service を機能別に分割

#### 5. Dependency Inversion Principle（依存性逆転の原則）
- 上位モジュールは下位モジュールに依存しない
- 例: Provider → Service の依存（直接 Firebase に依存しない）

### クリーンアーキテクチャの考え方

```
外側（不安定） → 内側（安定）

UI → Provider → Service → Model
         ↓
      Config
```

- **UI（最も不安定）**: 頻繁に変更される
- **Provider**: ビジネスロジックを呼び出す
- **Service（安定）**: 再利用可能なロジック
- **Model（最も安定）**: データ構造

## ベストプラクティス

### 1. 責務の分離
- **Screen**: UI のみ、ロジックは Provider に委譲
- **Provider**: 状態管理、Service を呼び出す
- **Service**: ステートレスなロジック

### 2. 依存関係の管理
```dart
// Good: Provider を経由
final authProvider = Provider.of<AuthProvider>(context);
await authProvider.login(email, password);

// Bad: 直接 Firebase を呼ぶ
await FirebaseAuth.instance.signInWithEmailAndPassword(...);
```

### 3. エラーハンドリング
```dart
// Good: 一箇所で変換
catch (FirebaseAuthException e) {
  _errorMessage = AuthService.getAuthErrorMessage(e);
}

// Bad: 各所で switch 文
catch (FirebaseAuthException e) {
  switch (e.code) { ... }
}
```

### 4. 設定の一元管理
```dart
// Good: 設定から取得
if (password.length < FirebaseConfig.minPasswordLength) { ... }

// Bad: マジックナンバー
if (password.length < 6) { ... }
```

### 5. テスタビリティ
- Service クラスは静的メソッドで実装（テストしやすい）
- Provider は依存注入が可能な設計
- Mock を使ったテストが容易

## 今後の拡張

### Firestore 統合
```
lib/services/
  └── firestore_service.dart  # Firestore 操作

lib/repositories/
  ├── user_repository.dart    # ユーザーデータ
  ├── post_repository.dart    # 投稿データ
  └── comment_repository.dart # コメントデータ
```

### Storage 統合
```
lib/services/
  └── storage_service.dart    # ファイルアップロード
```

### API 統合
```
lib/services/
  └── api_service.dart        # バックエンドAPI通信

lib/repositories/
  └── api_repository.dart     # API呼び出しラッパー
```

## パフォーマンス最適化

### 1. 状態管理の最適化
```dart
// Consumer で必要な部分のみ再描画
Consumer<AuthProvider>(
  builder: (context, authProvider, child) {
    return Text(authProvider.currentUser?.username ?? '');
  },
)
```

### 2. Firebase の最適化
- キャッシュの活用（Firestore）
- オフラインサポート
- インデックスの作成

### 3. 画像の最適化
- 遅延読み込み
- キャッシュ戦略
- リサイズ

## セキュリティ考慮事項

### 1. 認証
- Firebase Auth のセキュリティルール
- トークンの管理
- セッションの有効期限

### 2. Firestore
- セキュリティルールの設定
- ユーザー権限の管理
- データの検証

### 3. Storage
- アップロード制限
- ファイルタイプの検証
- アクセス権限の設定

## まとめ

このアーキテクチャは以下を実現します：

✅ **可読性**: 責務が明確で理解しやすい
✅ **保守性**: 変更の影響範囲が限定的
✅ **拡張性**: 新機能の追加が容易
✅ **テスタビリティ**: ユニットテストが書きやすい
✅ **再利用性**: コードの重複を避ける

